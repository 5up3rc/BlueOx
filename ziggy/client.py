# -*- coding: utf-8 -*-

"""
ziggy.client
~~~~~~~~

This module provides utilities for writing client applications which connect or use ziggy data.

:copyright: (c) 2012 by Rhett Garber
:license: ISC, see LICENSE for more details.

"""
import logging
import struct

import bson
import zmq

log = logging.getLogger(__name__)

def decode_stream(stream):
    """A generator which reads data out of the buffered file stream, unpacks and decodes the ziggy events

    This is useful for parsing on disk log files generated by ziggyd
    """
    while True:
        # BSON is encoded with a 32-bit int size in bytes of the structure as
        # the first two bytes.  We're going to peek at that size (using the
        # magic of buffered io), then load them up one structure at a time
        size_data = stream.peek(2)[:2]
        if len(size_data) < 2:
            break

        size = struct.unpack("H", size_data)[0]
        data = stream.read(size)
        yield bson.loads(data)

def retrieve_stream_host(context, control_host):
    poller = zmq.Poller()
    sock = context.socket(zmq.REQ)
    sock.connect("tcp://%s" % control_host)
    poller.register(sock, zmq.POLLIN)

    sock.send(bson.dumps({'cmd': 'SOCK_STREAM'}))

    result = dict(poller.poll(5000))
    if sock in result:
        result = bson.loads(sock.recv())
        host, _ = control_host.split(':')
        return "%s:%d" % (host, result['port'])
    else:
        log.warning("Failed to connect to server")
        return None

def subscribe_stream(control_host, subscribe):
    context = zmq.Context()

    while True:
        stream_host = retrieve_stream_host(context, control_host)
        if stream_host is None:
            return

        sock = context.socket(zmq.SUB)

        prefix = False
        if subscribe:
            if subscribe.endswith('*'):
                prefix = True
                subscription = subscribe[:-1]
            else:
                subscription = subscribe
        else:
            subscription = ""

        sock.setsockopt(zmq.SUBSCRIBE, subscription)
        log.info("Connecting to %s" % (stream_host,))
        sock.connect("tcp://%s" % (stream_host,))

        # Now that we are connected, loop almost forever emiting events.
        # If we fail to receive any events within the specified timeout, we'll quit
        # and verify that we are connected to a valid stream.
        poller = zmq.Poller()
        poller.register(sock, zmq.POLLIN)
        while True:
            result = dict(poller.poll(5000))
            if sock not in result:
                 break

            parts = sock.recv_multipart()
            if len(parts) == 2:
                channel, data = parts
                # If the client only want exact matches, we'll skip this guy.
                if not prefix and subscription and channel != subscription:
                    continue

                yield bson.loads(data)
            else:
                break
