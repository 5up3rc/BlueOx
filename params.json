{"name":"Blueox","body":"BlueOx is a python based logging and data collection framework. The problem it\r\nattempts to solve is one where you have multiple python processes across\r\nmultiple hosts processing some sort of requests. You generally want to collect:\r\n\r\n  * Performance data (counters, timers, etc)\r\n  * User activity\r\n  * Errors (and debugging data)\r\n\r\nUse BlueOx to record that data, aggregate it to a central logging server where\r\nit can be written to disk.\r\n\r\nIn addition, it's often useful to be able to plug reporting scripts into the\r\nlogging server so as to generate live stats and reports or do ad hoc analysis.\r\n\r\nBlueOx's collection functionality is fairly advanced allowing heirarchies of\r\ncollectors and queuing in the event of failure. For example, it's recommend to\r\nrun an instance of `oxd` on each host, and then configure each of those\r\ncollectors to forward log events to a central collector on a dedicated log\r\nmachine.\r\n\r\nBlueOx is named after Paul Bunyan's Blue Ox \"Babe\". A great help for giant logging problems.\r\n\r\nInstallation\r\n----------------\r\n\r\nBlueOx requires Python 2.7, ZeroMQ and BSON.\r\n\r\nThe full python library requirements are given `requirements.txt` and is designed to be used with virtualenv.\r\n\r\nTornado is not required for operation of BlueOx, but development and running tests will likely require it.\r\n\r\nI expect debian packaging will be developed soon.\r\n\r\nApplication Integration\r\n-----------------\r\n\r\nApplications emit BlueOx events by using a context manager and globally accessible BlueOx functions.\r\n\r\nEvents have a type, which indicates what will be ultimately logged together.\r\n\r\nEvents also have an id that can be used to tie them together with other related events.\r\n\r\nFor example, in a web application, an application might choose the use BlueOx as follows:\r\n\r\n\r\n    def handle(request):\r\n        with blueox.Context('request'):\r\n            blueox.set('user_agent', self.headers['UserAgent'])\r\n\r\n            with blueox.timeit('request_time'):\r\n                do_stuff()\r\n\r\n            blueox.set('response.status', self.response.status)\r\n            blueox.set('response.size', len(self.response.body))\r\n\r\n\r\nThe above sample would generate one event that contains all the details about a\r\nspecific request.\r\n\r\nContexts can be heirarchical. This means you can generate sub-events that\r\nare related to the parent event and can be joined together in post-processing by the common id they share.\r\nIndicate you want this behavior for your context by naming with a prefixing '.'.\r\n\r\nFor example, inside some application code (in `do_stuff()` above), you might execute some sql queries.\r\n\r\n    def execute(cursor, query, args):\r\n        with blueox.Context('.sql'):\r\n            blueox.set('query', query)\r\n            with blueox.timeit('query_time'):\r\n                res = cursor.execute(query, args)\r\n            blueox.set('row_count', len(res))\r\n        return res\r\n\r\nEach SQL query would then be logged as a seperate event. However, each event\r\nwill have the unique id provided by the parent `request` context. The name of the context will become `request.sql`.\r\n\r\nYou can provide you're own id or allow BlueOx to autogenerate one for the top-level context.\r\n\r\nBlueOx also provides the ability to do sampling. This means only a set\r\npercentage of generate events will actually be logged. You can choose sampling\r\nbased on any level of the context:\r\n\r\n    with blueox.Context('.memcache', sample=('..', 0.25)):\r\n        blueox.set('key', key)\r\n        client.set(key, value)\r\n\r\nIn the above example, only 25% of requests will include the memcache data. If\r\nthe sample argument where `('memcache', 0.25)` then 25% of all memcache\r\nevents would be logged.\r\n\r\n### Configuration\r\n\r\nIf BlueOx has not been explicitly configured, all the calls to BlueOx will essentially be no-ops. This is\r\nrather useful in testing contexts so as to not generate a bunch of bogus data.\r\n\r\nFor production use, you'll need to set the collection host and port:\r\n\r\n    blueox.configure(\"127.0.0.1\", 3514)\r\n\r\n### Logging module integration\r\n\r\nBlueOx comes with a log handler that can be added to your `logging` module setup for easy integration into existing logging setups.\r\n\r\nFor example:\r\n\r\n    handler = blueox.LogHandler()\r\n    handler.setLevel(logging.INFO)\r\n    logging.getLogger('').addHandler(handler)\r\n\r\nBy default, all log event will show up as a sub-event `.log` but this can be\r\nconfigured by passing a type_name to the `LogHandler`\r\n\r\n### Tornado Integration\r\n\r\nBlueOx comes out of the box with support for Tornado web server. This is\r\nparticularly challenging since one of the goals for BlueOx is to, like the\r\nlogging module, have globally accessible contexts so you don't have to pass\r\nanything around to have access to all the heirarchical goodness.\r\n\r\nSince you'll likely want to have a context per web request, it's difficult o\r\nwork around tornado's async machinery to make that work well.\r\nFear not, batteries included: `blueox.tornado_utils`\r\n\r\nThe most straightfoward way to integrate BlueOx into a tornado application requires two things:\r\n\r\n  1. Allow BlueOx to monkey patch async tooling (tornado.gen primarily)\r\n  1. Use or re-implement the provided base request handler `blueox.tornado_utils.SampleRequestHandler`\r\n\r\nTo install the monkey patching, add the line:\r\n\r\n    blueox.tornado_utils.install()\r\n\r\nThis must be executed BEFORE any of your RequestHandlers are imported.\r\n\r\nThis is required if you are using `@web.asynchronous` and `@gen.engine`. If you are\r\nmanually managing callbacks (which you probably shouldn't be), you'll need\r\nmanually recall the BlueOx context with `self.blueox.start()`\r\n\r\nSee `tests/tornado_app.py` for an example of all this.\r\n\r\nIf you have your own base request handlers you'll likely want to reimplement\r\nbased on the one provided rather than trying to use inheritance. This will also\r\nmake it really clear what you are including in your top-level event and allow\r\nyou to name it whatever you want.\r\n\r\n\r\nEvent Collection\r\n-----------------\r\n\r\nEvents are collected by a BlueOx daemon (`oxd`) and can be configured in a variety of topologies.\r\n\r\nIt's recommended that you run a BlueOx daemon on each host, and then a master BlueOx daemon that collects \r\nall the streams together for logging. In this configuration, failure of the centralized collector would not\r\nresult in any data loss as the local instances would just queue up their events.\r\n\r\nSo on your local machine, you'd run:\r\n\r\n    oxd --forward=master:3514\r\n\r\nAnd on the master collection machine, you'd run:\r\n\r\n    oxd --collect=\"*:3514\" --log-path=/var/log/blueox/\r\n\r\nLogs are stored in BSON format, so you'll need some tooling for doing log\r\nanalysis. This is easily done with the tool `oxview`.\r\n\r\nFor example:\r\n\r\n    cat /var/log/blueox/request.120310.bson | oxview\r\n\r\n    oxview --log-path=/var/log/blueox --type-name=\"request\" --start-date=20120313 --end-date=20120315\r\n\r\nWhere `request` is the channel you want to examine.\r\n\r\nYou can also connect to `oxd` and get a live streaming of log data:\r\n\r\n    oxview -H localhost:3513 --type-name=\"request*\"\r\n\r\nNote the use of '*' to indicate a prefix query for the type filter. This will\r\nreturn all events with a type that begins with 'request'\r\n\r\n### A Note About Ports\r\n\r\nThere are several types of network ports in use with BlueOx:\r\n\r\n  1. Control Port (default 127.0.0.1:3513)\r\n  1. Collection Port (default 127.0.0.1:3514)\r\n  1. Streaming Port (no default, randomonly assigned)\r\n\r\nBoth the Control and Collection ports are configurable from the command line.\r\n\r\nWhen configuring forwarding between oxd instances, you'll want to always use\r\nthe collection port. \r\n\r\nWhen configuring an application to send data to a oxd instance, you'll want\r\nto use the collection port as well.\r\n\r\nFor administrative (and `oxview` work) you'll use the control port. The\r\ncontrol port (and BlueOx administrative interface) can be used to discover all\r\nthe other ports. The reason the collection port must be configured explicitly\r\nfor actual logging purposes is to better handle reconnects and failures.\r\n\r\n\r\nAdministration\r\n---------------\r\nUse the `oxctl` tool to collect useful stats or make other adjustments to a running oxd instance.\r\n\r\nFor example:\r\n\r\n    oxctl status\r\n\r\nor\r\n\r\n    oxctl shutdown\r\n","tagline":"A library for python-based application logging and data collection","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}